# 嵌入式工作中常用的 linux 命令

“” 双引号内的特殊字符，如 $，可以保持其原本的特性
''单引号内的特殊字符仅为一般字符
\^ 表示行首，加[\]和不加\[]表示的意义不同
\$ 表示行尾

组合按键|执行结果
:-:|:-:
ctrl + c | 终止目前的命令
ctrl + d | 输入结束符EOF
ctrl + m | 回车
ctrl + z | 暂停目前的命令

通配符|意义
:-:|:-:
\* | 代表任意字符（0到无穷多个）
? | 代表一定有一个字符
[] | 同样代表一定有一个字符<br>[abcd]表示一定有一个字符，可能是abcd中的任意一个
[-] | 表示在编码顺序内的所有字符，但只能是一个<br>[0-9]表示0~9之间的数字，任意一个
[\^] | 反向选择<br>[^abc]表示一个字符，但不能是a、b、c中的

## cut

在文件负责剪切数据用的。从文件的每一行剪切字节、字符和字段，并将这些字节、字符和字段输出

```shell
cut [选项参数] filename
#默认的分割符是制表符
#-f 列号，提取第几列
#-d 分隔符，按照指定分隔符分割列
```

```shell
cut -d “ ” -f 1 xx.txt
#以空格位分割符切割，并提取第一列，切割完原文件不会变
#如果空格不一致，只会按一个空格来切
cut -d “ ” -f 2- xx.txt
#2- 表示切完后取第2行及以后的列，包括分隔符
cut -d “ ” -f -2 xx.txt
#-2 表示切完取前两列的，包括分隔符
```

## grep
cut 表示在一行信息当中，取出某部分我们想要的；而 grep 则是分析一行信息，若当中有我们想要的，就将该行拿出来。
```shell
grep [选项参数] [--color=auto] '查找字符' filename
-i 忽略大小写
-n 输出行号
-v 反向选择
--color=auto 找出的部分加上颜色
```
## sed
sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为模式空间，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件结尾。**文件内容并没有改变，除非你使用重定向存储输出。**

```shell
sed [选项参数] ‘command’ filename
#选项参数
#-e 有多个命令执行的时候，需要在每个命令前面加-e
#命令功能
#a 新增，a的后面可以接字符串，在下一行出现
#d 删除
#s 查找并替换
```
```shell
sed ‘2a duan’ xx.txt
#在xx.txt文件的第二行后面增加一行，并填入duan
sed ‘/duan/d’ xx.txt
#在xx.txt文件中删除包含“duan”的行
sed ‘s/wo/ni/’ xx.txt
#在xx.txt文件中将第一个出现“wo”的行替换成“ni”
sed ‘s/wo/ni/g’ xx.txt
#在xx.txt文件中将所有的“wo”替换成“ni”
sed -e ‘2d’ -e ‘s/wo/ni/g’ xx.txt
#在xx.txt文件中，删除第二行，并将所有的“wo”替换成“ni”
```

## awk
sed 常常作为作用于一整个行的处理，awk 比较倾向于一行当中分成数个字段来处理

```shell
awk [选项参数] '条件类型1{操作1} 条件类型2{操作2}' filename
#选项参数：  
#-F 指定的分隔符
#-v 赋值一个用户定义变量

awk -F : '/^root/ {print $7}' passwd
#对passwd文件以:分割，并取出以root为行首的行的第七列
awk -F : '/^root/ {print $1","$7}' passwd
awk -F : 'BEGIN{print "user,shell"} {print $7} END{print "duan"}' passwd
#只显示文件的第一列和第七列，以逗号分割，且在第一行行前面添加一行user,shell，在最后一行后添加duan。
awk -F : -v i=1 '{print $3+i}' passwd
#将passwd文件的第三列加1并输出
#在awk中，变量可以直接使用，不需要加$符号
```
awk中内置的变量
变量|说明
:-:|:-:
FILENAME|文件名
NR | 已读的记录数
NF | 切割后，列的个数

```shell
awk -F : '{print FILENAME "," NR ", " NF}' passwd
#统计passwd文件名，每行的行号，每行的列数
ifconfig ens33 | grep "inet[^0-9]" | awk -F " " '{print $2}'
#切割IP，$0为整行，$1为第一列，$2为第二列，···

```

## sort
它将文件排序，并将排序结果标准输出

```shell
sort 选项 参数
选项：  
-n 依照数值大小排序
-r 以相反的顺序排序
-t 设置排序时所用的分隔符
-k 指定需要排序的列
参数：待排序的文件列表

sort -t : -nrk 2 xxx
#对xxx文件以:为分隔符，对第二列按照数值大小进行反向排序
```